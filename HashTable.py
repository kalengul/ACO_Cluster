# -*- coding: utf-8 -*-
"""
Created on Thu Jul 28 11:04:00 2022

@author: Юрий
"""

#Hashlist, разрешать конфликты методом цепного адреса
# Связанный класс узла списка, есть домен данных и домен указателя
class Node:
    def __init__(self,data = None):
        self.data = data
        self.next = None

class Hashtable:
    def __init__(self,size):# Этот метод записи должен предоставить длину хеш-таблицы при построении хеш-таблицы
        # Создать пустой список как хеш-таблицу, каждый элемент списка имеет тип узла
        self.data = [Node()] * size
        self.size = size
    #Функция Hash использует метод деления и оставления остатка. Разделите данные на длину хеш-таблицы и возьмите остаток.
    def hash_function(self,key,size):
        return key % size
    # Вставить данные в хеш-таблицу и построить хеш-таблицу, вставляя их по одному
    def put(self,key):
        # Найдите хеш-значение вставляемых данных
        hash_value = self.hash_function(key,self.size)
        # Если позиция хеш-значения в связанном списке не занята другими данными, поместите данные для вставки (ключ) непосредственно в эту позицию
        if self.data[hash_value].data == None:
            self.data[hash_value].data = key
        # Если он занят, последовательно проверять в связанном списке, начиная с [положение хеш-значения в хеш-таблице, пока не будет проверена пустая позиция
        else:
            # Ситуация, когда начальная точка вышеупомянутого связанного списка пуста, помогла установить узел, просто измените поле данных на ключ.
            # Когда начальная точка связанного списка уже занята, необходимо создать новый узел для хранения данных
            temp = Node(key)
            #p указывает на головной узел связанного списка, начиная с [позиции, где нижний индекс является значением хеш-функции в хеш-таблице].
            p = self.data[hash_value]
            # Проверять поочередно назад
            while p.next != None:
                p = p.next
            # Теперь save p указал на конец связанного списка, следующий из p может быть связан с temp
            p.next = temp
    # Определение наличия определенного значения (ключа) в хеш-таблице
    def get(self,key):
        # Получить хеш-значение оцениваемого элемента
        hash_value = self.hash_function(key,self.size)
        # Хранение элементов с одинаковым хеш-значением в связанном списке в соответствующей позиции хеш-таблицы нерегулярно
        # Простой случай, заголовок связанного списка под хеш-значением равен ключу, указывающему на то, что он найден
        if self.data[hash_value].data == key:
            return True
        # Когда заголовок связанного списка, соответствующий хэш-значению, не является ключом
        else:
            #pStorage заголовок связанного списка
            p = self.data[hash_value]
            # Пока ключ не встречается и конец связанного списка не достигнут, смотрите назад
            while p != None and p.data != key:
                p = p.next
            # После выхода из верхнего цикла он не дошел до конца связанного списка, что означает, что он был найден
            if p != None and p.data == key:
                return True
        # Весь связанный список не найден, что указывает на отсутствие узла, хранящего ключ во всей хэш-таблице
        return False
    # Удалить узел, данные которого являются ключом в хэш-таблице
    def delete(self,key):
        # Если ключа ввода нет в этой хеш-таблице, вернуть ошибку
        if not self.get(key):
            return 'Delete Error'
        # В противном случае существует узел, хранящий эти данные в хеш-таблице. Сначала найдите хеш-значение, соответствующее данным.
        hash_value = self.hash_function(key,self.size)
        # И функция get полностью аналогичны. Если данные заголовка связанного списка, соответствующие хеш-значению в хеш-таблице, совпадают с данными, подлежащими удалению, поле данных узла (заголовок связанного списка) напрямую изменяется на «Нет».
        # Пробел тратится впустую, но не влияет на поиск вставки.
        if self.data[hash_value].data == key:
            self.data[hash_value].data = None
        # В противном случае удаляемые данные находятся в соответствующем связанном списке    
        else:
            #p сначала указывает на головной узел связанного списка в этой позиции
            p = self.data[hash_value]
            #pre сохраняет узел перед текущим узлом связанного списка. Установите pre для подключения предыдущего узла к следующему узлу после удаления цели. Изначально p указывает на голову, а pre пусто.
            pre = None
            # Найдите позицию для удаления, обновляйте p и перед каждым шагом
            while p != None and p.data != key:
                pre = p
                p = p.next
            # Если конец все равно не найден (этот футляр тоже можно убрать)
            if p == None:
                return 'Delete Error'
            else:
                pre.next = p.next